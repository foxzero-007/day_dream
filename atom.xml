<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>而立的小破栈</title>
  
  <subtitle>Just do it ！</subtitle>
  <link href="https://laocuicode.cn/daydream/atom.xml" rel="self"/>
  
  <link href="https://laocuicode.cn/daydream/"/>
  <updated>2022-04-05T15:50:00.000Z</updated>
  <id>https://laocuicode.cn/daydream/</id>
  
  <author>
    <name>而立</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>硬核冷知识：V8与WebAssembly不得不说的秘密</title>
    <link href="https://laocuicode.cn/daydream/2022/04/01/202241-%E7%A1%AC%E6%A0%B8%E5%86%B7%E7%9F%A5%E8%AF%86%EF%BC%9AWebAssembly/"/>
    <id>https://laocuicode.cn/daydream/2022/04/01/202241-%E7%A1%AC%E6%A0%B8%E5%86%B7%E7%9F%A5%E8%AF%86%EF%BC%9AWebAssembly/</id>
    <published>2022-04-01T02:50:00.000Z</published>
    <updated>2022-04-05T15:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="硬核冷知识：V8与WebAssembly不得不说的秘密"><a href="#硬核冷知识：V8与WebAssembly不得不说的秘密" class="headerlink" title="硬核冷知识：V8与WebAssembly不得不说的秘密"></a>硬核冷知识：V8与WebAssembly不得不说的秘密</h1><blockquote><p>一切可编译为WebAssembly的，终将被编译为WebAssembly。</p></blockquote><h2 id="V8执行原理"><a href="#V8执行原理" class="headerlink" title="V8执行原理"></a>V8执行原理</h2><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/v8%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p><p>从整体流程来看，v8引擎执行js代码的关键步骤在于</p><ul><li>AST语法树生成</li><li>字节码生成</li><li>解释器</li><li>JIT（优化编译器，监控模块）</li></ul><p>对于整体流程的解释与分析这里不再赘述，详情可查看北渊大佬的博客<a href="https://www.zoo.team/article/the-process-of-executing-js-in-v8">v8 执行 js 的过程</a></p><h2 id="JIT和AOT定义-amp-对比"><a href="#JIT和AOT定义-amp-对比" class="headerlink" title="JIT和AOT定义&amp;对比"></a>JIT和AOT定义&amp;对比</h2><p>JIT和AOT是对当下两种最为流行的代码编译方式的定义</p><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><blockquote><p>JIT（Just-In-Time）：即时编译，又称动态编译</p></blockquote><ul><li>JIT的特点在于不对代码做完整的编译，而是随着程序的运行逐行编译</li></ul><h3 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h3><blockquote><p>AOT（Ahead-Of-Time）：预先编译，又称静态编译</p></blockquote><ul><li>AOT的特点在于在程序运行之前将所有代码进行编译，而后将完整的程序机器码交由操作系统执行</li></ul><h3 id="Differences"><a href="#Differences" class="headerlink" title="Differences"></a>Differences</h3><blockquote><p>两者的区别</p><p>（ps：两者的区别就好像当我们看一篇外文文章时采用不同的翻译方式）</p></blockquote><ul><li><p>JIT的方式就像我们在阅读文章时采用划词翻译的方式，我们可以完全根据自己的进度去翻译文章</p><ul><li>启动速度快，不需要等待全文翻译</li><li>优化，根据当前的上下文对翻译内容进行优化</li></ul></li><li><p>AOT的方式更像google全文翻译，在阅读文章之前，google会将整篇文章转化为我们熟知的语言</p><p><em><del>（妈妈再也不用担心我看不懂英文了）</del></em> </p><ul><li>阅读速度快，不需要再收到外语的干扰</li><li>减少思考时间，不需要去对上下文分析解析语意</li></ul></li></ul><blockquote><p>常用语言分类</p><p>AOT：c/c++，Go</p><p>JIT：javascript，python</p><p>解释型语言和编译型语言的区分很多时候都是靠编译的种类来区分，一般而言，使用AOT方式编译的语言都被称为编译型语言</p></blockquote><h2 id="JavaScript的-（性史）-性能史"><a href="#JavaScript的-（性史）-性能史" class="headerlink" title="JavaScript的*（性史）*性能史"></a>JavaScript的*<del>（性史）</del>*性能史</h2><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/v8%E5%9B%BE%E6%A0%87.jpeg" style="zoom:67%;" /><h3 id="早期V8的传说"><a href="#早期V8的传说" class="headerlink" title="早期V8的传说"></a>早期V8的传说</h3><p>早期的V8引擎为了提高javascript的运行效率，曾一度放弃JavaScriptCore引擎（WebKit内核的js引擎）中的<strong>“字节码解释器”</strong>，直接在AST语法树的基础上进行JIT即时编译，将JavaScript直接编译为机器码，以达到近乎二进制代码的运行速度，其执行过程核心组成大致如下：</p><ul><li><h4 id="Full-codegen编译器"><a href="#Full-codegen编译器" class="headerlink" title="Full-codegen编译器"></a>Full-codegen编译器</h4><p>又称基线编译器，是v8引擎中最简单的编译器，它可以基于AST抽象语法树直接编译成机器码，因其在编译过程中对机器码不做任何优化，生成基准的未经优化的机器码，故也称为基准编译器。</p></li><li><h4 id="Crankshaft优化编译器"><a href="#Crankshaft优化编译器" class="headerlink" title="Crankshaft优化编译器"></a>Crankshaft优化编译器</h4><p>CrankShaft是V8引擎中最早使用的<strong>优化</strong>编译器，在传统意义上，编译过程应当会阻塞代码的运行，但Crankshaft的执行却不会，它是运行在另一个线程上的（注：这与JS本身单线程并不冲突，JS的单线程指的是JS执行过程中只有一个调用栈）</p></li><li><h4 id="TurboFan优化编译器"><a href="#TurboFan优化编译器" class="headerlink" title="TurboFan优化编译器"></a>TurboFan优化编译器</h4><p>尽管在很多文章中，大家都更倾向于将TurboFan优化编译器归结于V8引擎5.9版本以后的特点，但从V8的官方blog来看，TurboFan早在2015 年 7 月 13 日（<del>划重点，下文要用</del>）V8引擎4.5版本之前就已经开始有部分支持了，它具有新的分层架构，改变了传统编译器随着时间推移而变得复杂的问题，使得该编译器能够随着时间的推移应对复杂需求。</p></li></ul><p>从以上的核心来看，早期V8引擎实际上是没有解释器这一核心的，所有JS代码的执行全都是由编译器去进行处理，直接转换为操作系统可以运行的机器码，由于跳过了一个大步骤（字节码），所以其速度在当时远超其他JS引擎。</p><h3 id="结束传说的bug"><a href="#结束传说的bug" class="headerlink" title="结束传说的bug"></a>结束传说的bug</h3><p>过于超前的实践必然有其问题，为什么在浏览器引擎发展史中只有V8将字节码省略，直接生机器码，为什么其他引擎没有做出这样的改变？这一切的一切都与机器码本身有关，而V8去除字节码的这一操作也在发布不久之后产生了问题。</p><p>正如我们所知道的，所谓高级语言，其实都是对机器码进行一层又一层的<strong>“抽象”</strong>，可以说正是因为抽象水平的提高，才有了当下各种高级语言的发展，这些高度抽象的语言让人们得以用少量的代码完成复杂的计算机操作，但是，无论多么抽象的语言，他们最终的目的都是转换为机器码以让操作系统去执行这些操作，作为<strong>动态类型语言</strong>的JavaScript其抽象程度远比其他高级语言要高，因为其不确定的类型系统，使得其转换出的机器码远超其他语言，省去字节码这一操作的问题也就随之明了：</p><ul><li><p>大量的机器码会占据浏览器大量的内存，从而减缓了执行速度</p></li><li><p>对于机器码进行缓存时，无法对所有机器码缓存</p></li><li><p>根据V8的策略，往往是从最外层向内缓存，这就造成很多时候我们缓存的代码都只是最外层的生明，而不是内部的实现</p></li><li><p>V8将方法的实现留到第一次执行时才去编译，因而会造成重复解析的现象</p></li><li><p>由于机器码的体积较大，在运行过程中有许多只用到一次的代码也会被变为机器码缓存，极大浪费资源</p><p>……</p></li></ul><p>总的来说，去除字节码这一操作在当时还是产生了许多问题，这也就证明了字节码的重要性。</p><h3 id="V8的重生"><a href="#V8的重生" class="headerlink" title="V8的重生"></a>V8的重生</h3><div style="display:flex;justify-content:center;warp: no-warp">  <img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/v8%E8%A7%A3%E9%87%8A%E5%99%A8.png" alt="v8解释器" style="zoom:50%;" />  <img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/v8%E4%BC%98%E5%8C%96%E7%BC%96%E8%AF%91%E5%99%A8.png" alt="v8优化编译器" style="zoom:50%;" /></div>                                                                                       <p>说到V8引擎，其实大家都很喜欢提到一个特殊的版本<strong>V5.9</strong>，这个版本中，V8引擎进行了重大变革，将原有的基线编译器（Full-codegen）和优化编译器（CrankShaft）抛弃，正式启用了<strong>Ignition解释器</strong>（左），<strong>TurboFan优化编译器</strong>（右）</p><p>这一举措将V8引擎再一次带回到字节码时代，通过使用比机器码体积小许多的字节码，解决了机器码占用大量缓存的现象，同时提高了代码的启动速度，这一方式自<em>2017 年 4 月 27 日</em>发布，也是至今仍然持续使用的<strong>执行管道</strong>，V8也借此机会优化了本身的代码结构。</p><h2 id="WebAssembly发展史"><a href="#WebAssembly发展史" class="headerlink" title="WebAssembly发展史"></a>WebAssembly发展史</h2><h3 id="起于性能"><a href="#起于性能" class="headerlink" title="起于性能"></a>起于性能</h3><p>事实上，在V8引擎将JIT引入JS引擎开始，JS的性能已经达到了一个很高的水平，对于大部分日常业务来说，性能方面甚至是绰绰有余的，但这仅仅是针对日常业务来讲（类似于crud，按钮弹窗交互这种），如果以对性能要求更高一等的游戏来讲，V8引擎对于稍有量级的游戏仍然是心有余而力不足，这便使得V8开始向更高的性能进发，说到性能，目前高级语言中以性能作为特点的必然要想到C/C++，大量的3D游戏都是使用C/C++开发，再加上JS本身语法与C/C++差异并不大，于是开发者们便想着：<strong>如果将C/C++转换为JS代码，那不就可以做游戏了？</strong>从此，JS<del>（被迫）</del>多了一个子集<strong>asm.js</strong>。</p><h3 id="asm-js"><a href="#asm-js" class="headerlink" title="asm.js"></a>asm.js</h3><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/asmjs.png" alt="asmjs">JS和C/C++的差别主要有以下两点：</p><ul><li>C / C++ 是静态类型语言，而 JS 是动态类型语言。</li><li>C / C++ 是手动内存管理，而 JS 依靠垃圾回收机制。</li></ul><p>基于这两点，开发者们设计出了asm.js这项技术，它与常规js的区别就在于</p><ul><li><strong>它的变量一律都是静态类型</strong></li><li><strong>它取消垃圾回收机制</strong></li></ul><blockquote><p>asm.js只支持两种数据类型：</p><p>32位带符号整数，64位带符号浮点数</p><p>asm.js 的类型声明有固定写法，<code>变量 | 0</code>表示整数，<code>+变量</code>表示浮点数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//asm.js 语法示例</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = a|<span class="number">0</span></span><br><span class="line"><span class="comment">//原生js写法</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br></pre></td></tr></table></figure><p>上述写法中，原生js写法只有在运行过程中变量b才能知道自己的类型，而asm.js写法中变量b则是在声明时就已经知道了自己的类型。</p><blockquote><p>不就是加个类型嘛？这个我熟，TypeScript就是。。。。。。</p><p>[warn]虽然asm.js和TypeScript都是为JS添加了类型机制，但两者在本质上有着很大的区别：</p><ul><li>TypeScript：它的本质只是为JS增加了修饰，最终还是将转为js执行，本质上并没有任何性能优化，其作用只在<strong>限制杂乱的js写法</strong></li><li>asm.js：JIT为该子集有专门的优化，从编译层面对性能进行了优化和支持</li></ul></blockquote><p>（本篇对asm.js的相关语法不做特别详解，欲知后续，请等连载。。。）</p><h3 id="Emscripten"><a href="#Emscripten" class="headerlink" title="Emscripten"></a>Emscripten</h3><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/Emscripten.jpeg" alt="Emscripten"></p><p>上文提到asm.js基于其特殊的语法以及JIT为其特地准备的优化机制可以达到更高的性能，那么如果我们利用asm.js将C/C++代码重构必然是可以将原本用C/C++编写的程序和游戏移植到浏览器中，并且运行他们，但是使用js去重构C/C++项目无论是对精通js的程序猿还是精通C/C++的程序猿都是一个难题，那么asm.js难道就是一门<strong>使用条件极其严苛</strong>的鸡肋语言吗？</p><p>实际上asm.js本身与其说是一门编程语言，它更多的却像是一种<strong>中间代码语言</strong>（类似于字节码），它被设计出来的目的并不是有由程序猿人为的去编写相关程序，而是将C/C++代码编译为<strong>符合asm.js格式的代码</strong>，那么根据我们对编译原理的了解，在这个过程中有一个必不可少的工具——<strong>编译器</strong></p><p><strong>Emscripten</strong>就是与asm.js相辅相成的编译器</p><p>Emscripten 的底层是 LLVM 编译器，理论上任何可以生成 LLVM IR（Intermediate Representation）的语言，都可以编译生成 asm.js。 但是实际上，Emscripten 几乎只用于将 C / C++ 代码编译生成 asm.js。<del>(太专一了，没对象的男孩子们好好学学)</del></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C/C++ ⇒ LLVM ==&gt; LLVM IR ⇒ Emscripten ⇒ asm.js</span><br></pre></td></tr></table></figure><h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取源码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/emscripten-core/emsdk.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> emsdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取最新的版本(第一次clone不需要)</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载安装最新的SDK工具.</span></span><br><span class="line">./emsdk install latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让当前用户可以使用最新的SDK (修改 .emscripten file)</span></span><br><span class="line">./emsdk activate latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改环境变量</span></span><br><span class="line"><span class="built_in">source</span> ./emsdk_env.sh</span><br></pre></td></tr></table></figure><h4 id="Hello-World-！"><a href="#Hello-World-！" class="headerlink" title="Hello World ！"></a>Hello World ！</h4><p>首先创建halloWorld.cc文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其转换为asm.js</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ emcc helloWorld.cc</span><br><span class="line">$ node a.out.js</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p><strong>emcc</strong>是Emscripten的编译命令，默认生成a.out.js文件</p><p>对于emcc的简单使用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 a.out.js</span></span><br><span class="line">$ emcc helloWorld.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 helloWorld.js</span></span><br><span class="line">$ emcc helloWorld.c -o helloWorld.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 hello.html 和 hello.js</span></span><br><span class="line">$ emcc helloWorld.c -o helloWorld.html</span><br></pre></td></tr></table></figure><h3 id="WebAssembly诞生"><a href="#WebAssembly诞生" class="headerlink" title="WebAssembly诞生"></a>WebAssembly诞生</h3><p>随着asm.js和Emscripten的使用，js在很长一段时间中得以以一种很高的性能去运行一些相对来说性能需求较高的功能，但技术终究是技术，永远没有终点，asm.js和Emscripten仅仅是对C/C++可以使用，但强大的开发者们将其思想提炼，最终形成了<strong>WebAssembly</strong>这项技术。</p><h4 id="什么是WebAssembly？"><a href="#什么是WebAssembly？" class="headerlink" title="什么是WebAssembly？"></a>什么是WebAssembly？</h4><p>WebAssembly并不是确切的指某一种编程语言，它只是一个<strong>字节码标准</strong>，它的运行依赖于<strong>JS虚拟机环境</strong>（JS引擎）</p><p>webAssembly可以说是对asm.js的一种抽象，它不再局限于将源代码转换成js代码，而是以字节码作为中间代码，只要各种源码最终被编译为符合webAssembly格式的字节码（**.wasm文件**），那么js虚拟机就可以载入并运行它。</p><h4 id="Webassembly与asm-js以及原生js的区别"><a href="#Webassembly与asm-js以及原生js的区别" class="headerlink" title="Webassembly与asm.js以及原生js的区别"></a>Webassembly与asm.js以及原生js的区别</h4><blockquote><p>Webassembly与asm.js</p></blockquote><p>两者的功能基本一致，就是转出来的代码不一样：asm.js 是文本，WebAssembly 是二进制字节码，因此运行速度更快、体积更小。从长远来看，WebAssembly 的前景更光明。</p><p>但是，这并不意味着 asm.js 肯定会被淘汰，因为它有两个优点：首先，它是文本，人类可读，比较直观；其次，所有浏览器都支持 asm.js，不会有兼容性问题。</p><blockquote><p>Webassembly与原生js</p></blockquote><p>既然V8目前也会将js转换为字节码，那么两者是否等同呢？</p><p>其实两者依旧是不同的，由于js本身的语法特性如动态类型等，同样的操作其实对应的字节码与WebAssembly并不相同，相较之下，Webassembly的体积更小，格式更为紧凑，也更加接近机器码，因此Webassembly的运行要更加快，优势总结如下：</p><ul><li>大小：Webassembly文件更小，通过网络请求速度更快</li><li>解析：解码速度更快，本身经过编译，只要校验正确性完整性就可以</li><li>编译和优化：Webassembly本身已经进行过优化，所以优化更快</li><li>重新优化（反优化）：Webassembly本身不需要反优化，因为编译器在有足够的信息在第一次运行时获得最正确的代码</li><li>执行：执行速度更快，因为Webassembly的指令非常接近机器码</li><li>垃圾回收：手动控制垃圾回收，不支持自动回收，效率更高</li></ul><h4 id="从什么时候开始支持的"><a href="#从什么时候开始支持的" class="headerlink" title="从什么时候开始支持的"></a>从什么时候开始支持的</h4><p>尽管我是在最近两年才开始在各大论坛和博客中了解到这个名词，但V8早已在5.0版本之前就已经宣布对Webassembly开始实验性的支持，正如前文所说，V8在5.9版本之前实际上是没有采用解释器和字节码的，但他们却对Webassembly进行了支持，开发者们为Webassembly设计了一个单独的解码器<del>(舔狗行为)</del>，这不得不让我们感到惊讶，原来对这项技术的支持早已在<em>2016 年 3 月 15 日</em>甚至更早就已经被js引擎开发者们提上了日程。</p><h2 id="Webassembly的使用"><a href="#Webassembly的使用" class="headerlink" title="Webassembly的使用"></a>Webassembly的使用</h2><p>虽然目前很多语言尤其是Rust对Webassembly的支持已经愈发强大，但作者当前水平有限，因而依旧采用C/C++作为示例</p><h3 id="Emscripten环境安装"><a href="#Emscripten环境安装" class="headerlink" title="Emscripten环境安装"></a>Emscripten环境安装</h3><p>是的，你没有看错，就是那个可以将C/C++编译为asm.js的编译器，现在的它开始支持将C/C++编译为Webassembly了<del>(这就变心了？)</del></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/juj/emsdk.git</span><br><span class="line"><span class="built_in">cd</span> emsdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Linux 或者 Mac OS X 上</span></span><br><span class="line">./emsdk install --build=Release sdk-incoming-64bit binaryen-master-64bit</span><br><span class="line">./emsdk activate --global --build=Release sdk-incoming-64bit binaryen-master-64bit</span><br><span class="line"><span class="comment"># 如果在你的macos上获得以下错误</span></span><br><span class="line">Error: No tool or SDK found by name <span class="string">&#x27;sdk-incoming-64bit&#x27;</span></span><br><span class="line"><span class="comment"># 请执行</span></span><br><span class="line">./emsdk install latest</span><br><span class="line"><span class="comment"># 按照提示配置环境变量即可</span></span><br><span class="line">./emsdk activate latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Windows 上</span></span><br><span class="line">emsdk install --build=Release sdk-incoming-64bit binaryen-master-64bit</span><br><span class="line">emsdk activate --global --build=Release sdk-incoming-64bit binaryen-master-64bit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：Windows 版本的 Visual Studio 2017 已经被支持，但需要在 emsdk install 需要追加 --vs2017 参数。</span></span><br></pre></td></tr></table></figure><h3 id="生成HTML和JAVASCRIPT"><a href="#生成HTML和JAVASCRIPT" class="headerlink" title="生成HTML和JAVASCRIPT"></a>生成HTML和JAVASCRIPT</h3><ol><li><p>创建<code>hello.c</code>文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 emsdk 中搜索一个叫做 <code>shell_minimal.html</code> 的文件，然后复制它到刚刚创建的目录下的 <code>html_template</code> 文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir html_template</span><br><span class="line">cp ~/emsdk/emscripten/1.38.15/src/shell_minimal.html html_template</span><br></pre></td></tr></table></figure></li><li><p>现在使用你的Emscripten编译器环境的终端窗口进入你的新目录， 然后运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc -o hello.html hello.c -O3 -s WASM=1 --shell-file html_template/shell_minimal.html</span><br></pre></td></tr></table></figure><p>可以看到，Emscripten是通过<code>WASM=1</code>来控制生成asm.js或.wasm文件</p></li><li><p>上述代码会为我们生成一个含有“胶水代码”的html文件，直接打开，浏览器会为我们导入wasm文件并执行</p></li></ol><blockquote><p>更多示例或文档请前往<a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly/C_to_wasm">Webassembly官网</a></p><p>胶水代码：可以理解为将两种不同语言整合到一个文件中的代码，这里是指导入.wasm文件所使用的js代码</p></blockquote><h2 id="如何看待Webassembly？"><a href="#如何看待Webassembly？" class="headerlink" title="如何看待Webassembly？"></a>如何看待Webassembly？</h2><p>首先Webassembly本身并不会取代JavaScript，它是作为JavaScript弥补性能不足的工具而被开发出来的，尽管其性能优越，但是对于在Web端领头地位占据已久的JavaScript而言，性能并不是一切，无论是JavaScript还是Webassembly，我们的目标其实都是一致的，就是以更好更快的方式去完成页面的交互。</p><blockquote><p>文章参考：</p><p><a href="http://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html">asm.js 和 Emscripten 入门教程</a></p><p><a href="https://juejin.cn/post/6844903895110533133#heading-7">Webassembly不完全指北</a></p><p><a href="https://v8.dev/blog">V8引擎官网</a></p></blockquote>]]></content>
    
    
    <summary type="html">一切可编译为WebAssembly的，终将被编译为WebAssembly。</summary>
    
    
    
    <category term="前端学习" scheme="https://laocuicode.cn/daydream/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Web" scheme="https://laocuicode.cn/daydream/tags/Web/"/>
    
    <category term="WebAssembly" scheme="https://laocuicode.cn/daydream/tags/WebAssembly/"/>
    
    <category term="JavaScript" scheme="https://laocuicode.cn/daydream/tags/JavaScript/"/>
    
    <category term="V8引擎" scheme="https://laocuicode.cn/daydream/tags/V8%E5%BC%95%E6%93%8E/"/>
    
    <category term="编译" scheme="https://laocuicode.cn/daydream/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://laocuicode.cn/daydream/2022/03/25/hello-world/"/>
    <id>https://laocuicode.cn/daydream/2022/03/25/hello-world/</id>
    <published>2022-03-25T03:13:10.895Z</published>
    <updated>2022-03-25T03:13:10.895Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="hexo初始化" scheme="https://laocuicode.cn/daydream/categories/hexo%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
    
    <category term="Hallo World !" scheme="https://laocuicode.cn/daydream/tags/Hallo-World/"/>
    
  </entry>
  
  <entry>
    <title>浏览器内核详解</title>
    <link href="https://laocuicode.cn/daydream/2021/07/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"/>
    <id>https://laocuicode.cn/daydream/2021/07/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/</id>
    <published>2021-07-06T04:00:09.000Z</published>
    <updated>2021-07-06T07:09:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是浏览器内核？"><a href="#什么是浏览器内核？" class="headerlink" title="什么是浏览器内核？"></a>什么是浏览器内核？</h2><blockquote><p>一般我们常说的浏览器内核指的其实就是“渲染引擎”</p></blockquote><h3 id="浏览器的组成部分"><a href="#浏览器的组成部分" class="headerlink" title="浏览器的组成部分"></a>浏览器的组成部分</h3><blockquote><p>浏览器的组成主要有三部分：用户界面，浏览器引擎以及渲染引擎</p></blockquote><p><strong>用户界面</strong>：这个其实就是我们平常使用浏览器看到的一部分</p><p><strong>浏览器引擎</strong>：用于在用户界面和渲染引擎之间传递数据（一般来说这就是浏览器的数据持久层）</p><p><strong>渲染引擎</strong>：负责渲染用户请求的页面内容</p><ul><li><p>渲染引擎包括多个小的功能模块如：</p><p><code>网络模块</code>：负责网络请求</p><p><code>JS解析器</code>：用于解析和执行JS</p></li></ul><h2 id="常见浏览器内核以及其发展史"><a href="#常见浏览器内核以及其发展史" class="headerlink" title="常见浏览器内核以及其发展史"></a>常见浏览器内核以及其发展史</h2><blockquote><p>这部分就比较生硬了，貌似所有介绍者都喜欢介绍这部分</p></blockquote><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="image-20210706125850018"></p><p><em>上图截取自油管视频主Luke Lee的视频</em></p><ul><li>1991年<code>Berners Lee</code>建立了第一代浏览器<code>World Wide Web</code></li></ul><blockquote><p>Berners Lee是互联网发明者之一（妥妥的大佬）</p><p>World Wide Web 只支持显示图片和文本</p></blockquote><ul><li>1993年<code>Mosaic</code>问世</li></ul><blockquote><p>Mosaic可以同时显示文本和图片</p></blockquote><ul><li>1994年<code>网景</code>,<code>OPERA</code>发布</li></ul><blockquote><p>网景的开发人员有一部分曾参与Mosaic开发</p><p>只能显示HTML没有CSS和JS</p><p>相较于网景，opera使用较少</p></blockquote><ul><li>1995年<code>IE</code>诞生</li></ul><blockquote><p>万恶之源？自此第一次浏览器大战正式打响</p></blockquote><ul><li>1996年<code>IE3.0</code>发布且与windows融合</li></ul><blockquote><p>此时网景的市场份额仍有86%</p></blockquote><ul><li>1998年<code>网景</code>公司成立Mozilla基金会</li></ul><blockquote><p>基金会用来开发火狐浏览器</p></blockquote><ul><li>1999年<code>IE</code>占据99%市场</li></ul><blockquote><p>牛哇</p></blockquote><ul><li>2003年<code>Safari</code>浏览器问世</li></ul><blockquote><p>觉得眼熟？这就是苹果专用浏览器</p></blockquote><ul><li>2004年<code>Firefox(火狐)</code>问世</li></ul><blockquote><p>第二次浏览器大战序幕拉开</p></blockquote><ul><li>2005年苹果公司将<code>webkit</code>内核开源</li></ul><blockquote><p>为浏览器发展贡献巨大，开源yyds</p></blockquote><ul><li>2008年<code>google</code>以<code>webkit</code>为核心开发<code>chrome</code>和<code>chromium</code></li></ul><blockquote><p>最强浏览器诞生？</p></blockquote><ul><li>2015年微软推出以<code>webkit</code>为内核的浏览器<code>edge</code></li></ul><blockquote><p>来晚咯</p></blockquote><h3 id="各浏览器对应内核"><a href="#各浏览器对应内核" class="headerlink" title="各浏览器对应内核"></a>各浏览器对应内核</h3><p><code>IE</code>: Trident</p><p><code>FireFox</code>: Gecko</p><p><code>Safari</code>: Webkit</p><p><code>Chrome</code>,<code>Opera</code>,<code>Edge</code>: Blink(基于Webkit开发的)</p><h2 id="以Chrome为例介绍浏览器运行"><a href="#以Chrome为例介绍浏览器运行" class="headerlink" title="以Chrome为例介绍浏览器运行"></a>以Chrome为例介绍浏览器运行</h2><p>本质：浏览器本质上是运行在操作系统上的一个应用程序</p><blockquote><p>应用程序的特征：每个应用程序至少启动一个进程来执行功能</p><p>进程执行过程中由于有许多任务所以会创建线程来帮助执行</p></blockquote><p><strong>进程</strong>：是操作系统进行资源分配和调度的基本单元，可以申请和拥有计算机资源，进程是程序的基本执行实体</p><p><strong>线程</strong>：线程是操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务</p><p><strong>通俗点讲</strong>：应用程序启动后会创建多个进程。各个进程之间的内存空间不同，因此相互独立，进程之间通信需要通过<code>进程间通信管道IPC</code>来实现，每个进程可以将任务分成更多细小的人物，并通过创建多个线程<code>并行</code>执行不同的任务，同一进程下的线程是可以直接通信共享数据的</p><h3 id="浏览器进程介绍"><a href="#浏览器进程介绍" class="headerlink" title="浏览器进程介绍"></a>浏览器进程介绍</h3><p><strong>早期浏览器使用单进程</strong>：</p><ul><li>不稳定：其中一个线程的卡死会导致整个进程卡死</li><li>不安全：由于同一进程下的线程可以共享数据，js线程可以直接访问浏览器进程内的所有数据</li><li>不流畅：一个进程需要负责太多事情会导致运行效率问题</li></ul><p><strong>现代浏览器使用多进程</strong>：</p><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%93%E6%9E%84.png" alt="image-20210706133613130"></p><p><strong>浏览器进程</strong>：负责控制Chrome浏览器除标签页外的用户页面包括地址栏，书签，后退和前进按钮以及负责与浏览器的其他进程协调工作</p><p><strong>网络进程</strong>：负责发起/接受网络请求</p><p><strong>GPU进程</strong>：负责整个浏览器界面的渲染</p><p><strong>插件进程</strong>：负责控制网站使用的所有插件（如flash等）</p><p><strong>渲染器进程</strong>：用来控制显示tab标签内的所有内容</p><blockquote><p>浏览器在默认情况下会为每个标签页创建一个渲染器进程，这个操作与你启动Chrome时选择的进程模型有关</p></blockquote><h3 id="Chrome四种进程模型："><a href="#Chrome四种进程模型：" class="headerlink" title="Chrome四种进程模型："></a>Chrome四种进程模型：</h3><ul><li>process-per-site-instance(default)：为用户访问的每个实例创建一个渲染器进程，这样可以确保来自不同站点的页面是独立呈现的，并且对同一站点的单独访问也是彼此隔离的，<strong>简单来说就是访问不同站点或者访问同一站点的不同页面都会产生新的进程</strong></li><li>process-per-site：同一站点使用同一进程</li><li>process-per-tab：一个tab里的所有站点使用同一个进程</li><li>single-process：让浏览器引擎和渲染引擎共用一个进程</li></ul><h3 id="当你在浏览器地址栏输入网址"><a href="#当你在浏览器地址栏输入网址" class="headerlink" title="当你在浏览器地址栏输入网址"></a>当你在浏览器地址栏输入网址</h3><p>你知道当你在浏览器地址栏输入网址时，你的浏览器会做什么嘛：</p><h3 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h3><ul><li><p>首先，浏览器进程的UI会捕捉输入内容：</p><ul><li>如果访问的是网址，则UI线程会启动一个网络线程来请求DNS域名解析，接着开始连接服务器获取数据</li><li>如果输入的是一串关键词，浏览器会使用默认配置的搜索引擎来查询</li></ul></li><li><p>网络线程获取到数据之后：</p><p>当网络线程获取的数据后会通过SafeBrowsing来检查站点是否是恶意站点，如果是则会提示警告，当然你也可以强制访问</p><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE.png" alt="image-20210706135600907"></p><blockquote><p>SafeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全，比如查看IP是否在谷歌黑名单中</p></blockquote><p>当返回数据准备完毕并通过安全检验时，网络线程会通知UI线程，UI线程会创建一个渲染器进程来渲染页面，浏览器进程通过ICP将页面数据传递给渲染器进程</p></li></ul><h3 id="渲染器进程"><a href="#渲染器进程" class="headerlink" title="渲染器进程"></a>渲染器进程</h3><ul><li>渲染器进程接受到数据（HTML等），</li><li>核心任务是：html，css，js，image等资源渲染成用户可以交互的web页面</li><li>渲染器进程的主线程将html进行解析构造DOM数据结构</li></ul><blockquote><p>DOM（文档对象数据模型）是浏览器对页面在其内部的表示形式。是程序员通过js可与之交互的数据结构和API</p></blockquote><h3 id="HTML渲染主要步骤："><a href="#HTML渲染主要步骤：" class="headerlink" title="HTML渲染主要步骤："></a>HTML渲染主要步骤：</h3><p><strong>Html的解析主要包括两个部分</strong></p><ol><li><p><em>Tokeniser阶段</em></p><p>通过词法分析将HTML解析为多个标记</p><p>这是一个基于事件的HTML文本解析过程，最后会生成一个Token序列输出，当然此过程中来自网络的HTML不一定是整个文档，网络端接收到一部分HTML字节流时就会通知解析机解析该部分的内容。</p></li><li><p><em>TreeConstruction阶段</em></p><p>根据识别后的标记进行DOM树构造</p><p>Tokeniser阶段的Token序列产生后，就会把序列一个一个地输入到TreeConstruction中，最后输出DOMTree。</p></li></ol><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/HTML%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="image-20210706141138135"></p><blockquote><p>HTML解析过程中的几个重要点：</p><ol><li>CSS,image等静态资源需要从网络/本地存储中获取，这些资源加载不会阻塞html的解析</li><li>JS执行会阻塞html解析，其原因是浏览器无法确认js是否会改变dom结构，因此遇到script标签会直接执行，所以我们需要使用async或者defer属性异步加载js</li></ol></blockquote><ul><li><p>主线程解析完HTML后开始解析CSS（默认CSS或自定义CSS）</p><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/CSS%E6%B8%B2%E6%9F%93.png" alt="image-20210706141659015"></p></li><li><p>主线程解析完CSS后要确定元素在页面的位置。这个过程被称作<code>layout</code>布局</p><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/layout%E5%B8%83%E5%B1%80%EF%BC%881%EF%BC%89.png" alt="image-20210706141905267"></p></li><li><p> 主线程通过遍历dom和计算好的样式来生成<code>layout tree</code>：</p></li></ul><p>  ![image-20210706142031568](<a href="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/layout">https://chqosssave.oss-cn-beijing.aliyuncs.com/img/layout</a> tree.png)</p><blockquote><p>dom tree和layout tree不是一一对应的，设置了<code>display:none</code>的dom节点不会出现在layout tree上</p><p>在<code>before伪类</code>中添加了<code>content</code>值的元素，content里的内容会出现在layout tree上，不会出现在dom树里，这是因为dom tree是通过HTML解析获得，并不关心样式，而layout tree则是根据DOM和计算好的样式来生成</p></blockquote><ul><li><p>接下来主线程需要确定以什么样的顺序绘制节点</p></li><li><p>主线程遍历layout tree创建绘制记录表（Paint Record），该表记录了绘制的顺序（这个阶段被称为绘制）</p><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F%E8%A1%A8.png" alt="image-20210706142812893"></p></li><li><p>现在一切准备就绪，到了将这些信息转化为像素点显示到屏幕上的时候了，这个行为叫做<strong>栅格化(Rastering)</strong></p><ul><li>早期Chrome使用极其简单的方式进行栅格化，即只栅格化用户可见区域的内容，造成的缺点就是展示延迟（当你向下滚动时要等待页面加载）</li><li>而现在Chrome采用更为复杂的栅格化方式：**合成(Compositing)**：将页面的多个部分分成多个图层，分别对其进行栅格化，并在合成器线程(Compositor Thread)中单独进行合成页面的技术，简单来说就是页面所有的元素按照某种规则进行分图层并把图层都栅格化好了，然后只需要把可视区域的内容组合成一帧展示给用户即可</li></ul><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/Chrome%E6%A0%85%E6%A0%BC%E5%8C%96%E6%96%B9%E6%B3%95.png" alt="image-20210706143311472"></p></li><li><p>主线程遍历layout tree生成layer(图层) tree，当layer tree生成完毕和绘制顺序确定后</p><p>![image-20210706143811820](<a href="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/layer">https://chqosssave.oss-cn-beijing.aliyuncs.com/img/layer</a> tree.png)</p></li><li><p>主线程将这些信息传递给合成器线程，合成器线程将每个图层栅格化，合成器会将一个大页面分割成许多图块(tiles)，然后将每个图块发送给栅格化线程</p></li><li><p>栅格线程栅格每个图块，并将它们存储在GPU内存中</p></li><li><p>在栅格化线程结束后，合成器线程会收集称为“draw quads”的图块信息，这些信息记录了图块在内存中的位置和在页面哪个位置绘制图块的信息</p></li><li><p>根据这些信息合成器线程生成了一个合成器帧(Compositor Frame)</p><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/%E5%90%88%E6%88%90%E5%99%A8%E5%B8%A7.png" alt="image-20210706144501182"></p></li><li><p>然后合成器帧通过IPC传送给浏览器进程，浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上（页面渲染完成）</p></li><li><p>当页面滚动发生变化，则会生成新的合成器帧让后继续上述步骤</p></li><li><p>总流程如下：</p><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E6%A6%82%E6%8B%AC.png" alt="image-20210706144908915"></p></li><li><p>当排版发生改变，我们会重复上图过程，这个过程我们称为<strong>重排</strong></p></li><li><p>当我们改变某个元素的颜色属性时，不会触发重排，但是会触发样式的计算和绘制，这个过程称为<strong>重绘</strong></p><blockquote><p>重排和重绘都会占用主线程，而js也会占用主线程，当页面以60帧每秒（也就是每帧16ms）的刷新率时，用户才不会觉得卡顿，当页面在一帧的时间内布局和绘制结束后还有剩余时间，JS会获得主线程的使用权，如果JS执行时间过长就会导致下一帧开始时JS没有及时归还主线程，导致下一帧动画没有进行渲染，就会出现页面动画卡顿</p></blockquote></li><li><p>优化手段：</p><ul><li><p>通过requestAnimationFrame()来处理：</p><p>这个方法会在每一帧被调用，我们可以将js任务分为更小的任务块，在每一帧时间用完前暂停js执行归还主线程</p></li></ul><blockquote><p>React 最新的渲染引擎React fiber就用到这个API做了大量优化</p></blockquote><ul><li>CSS中有个动画属性叫做<code>transform</code>通过该属性实现动画不会经过布局和绘制，而是直接运行在合成器线程和栅格线程，不会占用主线程，更不会收到主线程中JS的影响</li></ul><blockquote><p>另外，transform动画由于不需要经过布局绘制，样式计算等操作，可以节省大量运算时间（方便实现动画）</p></blockquote><p><strong>transform动画取代原有动画实现</strong></p><p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/transform%E4%BB%A3%E6%9B%BF%E5%8A%A8%E7%94%BB.png" alt="image-20210706150318559"></p></li></ul>]]></content>
    
    
    <summary type="html">内核介绍以及以Chrome为例的内核渲染讲解</summary>
    
    
    
    <category term="前端学习" scheme="https://laocuicode.cn/daydream/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前端" scheme="https://laocuicode.cn/daydream/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="浏览器" scheme="https://laocuicode.cn/daydream/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="内核" scheme="https://laocuicode.cn/daydream/tags/%E5%86%85%E6%A0%B8/"/>
    
    <category term="Chrome" scheme="https://laocuicode.cn/daydream/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript进阶（2）</title>
    <link href="https://laocuicode.cn/daydream/2021/04/15/JavaScript%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/"/>
    <id>https://laocuicode.cn/daydream/2021/04/15/JavaScript%E8%BF%9B%E9%98%B6%EF%BC%882%EF%BC%89/</id>
    <published>2021-04-15T04:30:10.000Z</published>
    <updated>2021-04-20T02:44:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>定义和调用函数：（传统写法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn1(<span class="number">1</span>,<span class="number">2</span>));<span class="comment">//输出结果：3</span></span><br></pre></td></tr></table></figure><p>定义和调用函数：（ES6中的写法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn2=<span class="function">(<span class="params">a,b</span>)=&gt;</span> a+b;</span><br><span class="line"><span class="built_in">console</span>.log(fn2(<span class="number">1</span>,<span class="number">2</span>));<span class="comment">//输出结果：3</span></span><br></pre></td></tr></table></figure><p>二者的效果相同。</p><p>在箭头函数中，如果方法体内有两句话，那就需要在方法体外加上{}括号。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn2=<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;haha&#x27;</span>);</span><br><span class="line">               <span class="keyword">return</span> a+b;</span><br><span class="line">              &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fn2(<span class="number">1</span>,<span class="number">2</span>))<span class="comment">//输出结果：3</span></span><br></pre></td></tr></table></figure><p>从上方的箭头函数中，我们可以很清晰的找到函数名，参数名，方法体。</p><p>上方代码中：</p><ul><li>如果有且仅有1个参数，则（）可以省略</li><li>如果方法体内仅有1条语句，则{}可以省略，但前提是，这条语句必须是return。</li></ul><h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><blockquote><p>箭头函数只是为了让函数写起来更优雅吗？当然不是，还有一个很大的作用是与this的指向有关</p></blockquote><p>ES5中，this指向的是函数被调用的对象；而ES6的箭头函数中，this指向的是函数被定义时所指向的对象。</p><p>简单来说，箭头函数的this，是不会变的，永远绑定在当前的环境下。</p><h2 id="参考默认值"><a href="#参考默认值" class="headerlink" title="参考默认值"></a>参考默认值</h2><p><strong>传统写法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">param = <span class="string">&#x27;hello&#x27;</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log)(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ES6中定义方法时，我们可以给方法里的从参数加一个<strong>默认值</strong>（    缺省值）：</p><ul><li>方法被调用时，如果没有给参数赋值，那就用默认值；</li><li>方法被调用时，如果给参数复制了新的值，那就用新的值。</li></ul><p>如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn2=<span class="function">(<span class="params">a,b=<span class="number">5</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;haha&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fn2(<span class="number">1</span>));<span class="comment">//第二个参数使用默认值5，输出结果：6</span></span><br><span class="line"><span class="built_in">console</span>.log(fn2(<span class="number">1</span>,<span class="number">8</span>));<span class="comment">//输出结果：9</span></span><br></pre></td></tr></table></figure><p><strong>提醒1</strong>：默认值后面，不能再有<strong>没有默认值的变量</strong>。比如（a,b,c）这三个参数，如果我们给b设置了默认值，那么就一定要给c设置默认值。</p><p><strong>提醒2</strong>：</p><p>我们来看下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="string">&#x27;smyh&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x,y=x</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&#x27;vae&#x27;</span>);</span><br></pre></td></tr></table></figure><p>注意第二行代码，我们给y赋值x，这里的x是括号里的第一个参数，并不是第一行代码里定义的x，打印结果为<code>vae vae</code></p><p>如果我们将第一个参数修改一下，改成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="string">&quot;smyh&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">z,y=x</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(z,y);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&quot;vae&quot;</span>);</span><br></pre></td></tr></table></figure><p>此时打印结果为：<code>vae smyh</code></p><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>注意区分：</p><ul><li>扩展运算符的格式为：<code>...</code></li><li>rest运算符的格式为<code>...变量名</code></li></ul><p>有了ES6，当我们在定义一个方法，但是不确定其参数个数时，我们可以用<strong>扩展运算符</strong>作为参数。</p><p>以前，我们在定义方法时，参数要确定个数，如下：（程序会报错）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    <span class="built_in">console</span>.log(d);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，因为方法的参数是三个，但是使用的时候是用到了四个参数，所以会报错；</p><p>现在，我们有了扩展运算符，就不必担心报错的问题了。代码可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...arg</span>)</span>&#123;<span class="comment">//当不确定方法的参数时，可以使用扩展运算符</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(arg[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(arg[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(arg[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//方法中定义了四个参数，但是只引用了三个参数，ES6中并不会报错。</span></span><br></pre></td></tr></table></figure><p>上方代码中注意，arg参数之后，不能再加别的参数，否则会编译报错。</p><p><strong>举例</strong>：数组赋值问题</p><p>我们来分析一段代码：（将数组arr1赋值给arr2）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1=[<span class="string">&#x27;www&#x27;</span>,<span class="string">&#x27;smyhe&#x27;</span>,<span class="string">&#x27;com&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> arr2=arr1;<span class="comment">//将arr1赋值给arr2，其实是让arr2指向arr1的内存地址</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;arr1:&#x27;</span>+arr1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;arr2:&#x27;</span>+arr2);</span><br><span class="line">ocnsole.log(<span class="string">&#x27;------------------&#x27;</span>);</span><br><span class="line"></span><br><span class="line">arr2.push(<span class="string">&#x27;你懂的&#x27;</span>);<span class="comment">//往arr2里添加一部分内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;arr1:&#x27;</span>+arr1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;arr2:&#x27;</span>+arr2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><p>上方代码中，我们往arr2里添加le<code>你懂的</code>，却发现，arr1里面也有这个内容。原因是：<code>let arr2=arr1</code>其实是让arr2指向arr1的地址。也即是，二者指向的是同一个内存地址。</p><p>如果不想让arr1和arr2指向同一个内存地址，我们可以借助扩展运算符来做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1=[<span class="string">&#x27;www&#x27;</span>,<span class="string">&#x27;smyhvae&#x27;</span>,<span class="string">&#x27;com&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> arr2=[...arr1];<span class="comment">//arr2会重新开辟内存地址</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;arr1:&#x27;</span>+arr1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;arr2:&#x27;</span>+arr2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;----------------&#x27;</span>);</span><br><span class="line"></span><br><span class="line">arr2.push(<span class="string">&#x27;你懂的&#x27;</span>);<span class="comment">//往arr2里面添加一部分内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;arr1:&#x27;</span>+arr1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;arr2:&#x27;</span>+arr2);</span><br></pre></td></tr></table></figure><p>我们明白了这个例子，就可以避免开发中很多业务逻辑上的bug。</p><h2 id="rest运算符"><a href="#rest运算符" class="headerlink" title="rest运算符"></a><code>rest</code>运算符</h2><p><code>rest</code>在英文中指的是<strong>剩余部分</strong>（不是指休息）。</p><p>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">first,second,...arg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ar.length);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);<span class="comment">//调用函数后，输出结果为5</span></span><br></pre></td></tr></table></figure><p>上方代码的输出结果为5.调用<code>fn()</code>时，里面有七个参数，而<code>arg</code>指的是剩下的部分（因为除去了<code>first</code> 和<code>second</code>).</p><p>从上面的例子可以看出，<code>rest</code>运算符适用于：知道前面的一部分参数的数量，丹斯对于后面的剩余的参数数量未知的情况。</p>]]></content>
    
    
    <summary type="html">ES5,ES6特性详解</summary>
    
    
    
    <category term="前端学习" scheme="https://laocuicode.cn/daydream/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前端" scheme="https://laocuicode.cn/daydream/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JS" scheme="https://laocuicode.cn/daydream/tags/JS/"/>
    
    <category term="Ecmascript" scheme="https://laocuicode.cn/daydream/tags/Ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript进阶（1）</title>
    <link href="https://laocuicode.cn/daydream/2021/03/30/JavaScript%E8%BF%9B%E9%98%B6%EF%BC%88ES5=ES6%EF%BC%89/"/>
    <id>https://laocuicode.cn/daydream/2021/03/30/JavaScript%E8%BF%9B%E9%98%B6%EF%BC%88ES5=ES6%EF%BC%89/</id>
    <published>2021-03-30T04:30:10.000Z</published>
    <updated>2021-03-30T09:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a><strong>严格模式</strong></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>理解</strong>：ES5中添加的运行模式：“严格模式”（strict mode），该模式下javascript在更严格的语法条件下运行</p><p><strong>目的</strong>：</p><ul><li>消除js中语法的不合理，不严谨的地方</li><li>消除代码不安全之处</li><li>为未来新的js版本做铺垫</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>针对整个脚本文件：将use strict 放在整个脚本文件的第一行，则整个脚本文件将以严格模式运行。</li><li>针对单个函数：将use strict放在函数体的第一行，则整个函数以严格模式运行。</li></ul><h3 id="语法和行为改变"><a href="#语法和行为改变" class="headerlink" title="语法和行为改变"></a>语法和行为改变</h3><ul><li>必须使用var声明变量</li><li>禁止自定义的函数中的this指向window</li><li>对象不能有重名的属性</li></ul><h2 id="严格模式和普通模式的区别"><a href="#严格模式和普通模式的区别" class="headerlink" title="严格模式和普通模式的区别"></a>严格模式和普通模式的区别</h2><blockquote><p>仅列举一部分</p></blockquote><h3 id="全局变量显式声明"><a href="#全局变量显式声明" class="headerlink" title="全局变量显式声明"></a>全局变量显式声明</h3><p>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。在严格模式中禁止使用这种用法，全局变量必须显式声明。</p><h3 id="禁止this关键字指向全局对象："><a href="#禁止this关键字指向全局对象：" class="headerlink" title="禁止this关键字指向全局对象："></a>禁止this关键字指向全局对象：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上方代码中，普通模式打印的是window，严格模式下打印的是undefined。</p><h3 id="构造函数必须通过new实例化对象"><a href="#构造函数必须通过new实例化对象" class="headerlink" title="构造函数必须通过new实例化对象"></a>构造函数必须通过new实例化对象</h3><p>构造函数必须通过new实例化对象，否则报错。因为this为undefined，此时无法设置属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Cat(<span class="string">&#x27;haha&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上方代码，在严格模式下会报错。</p><h3 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h3><p>普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。</p><p>普通模式下，如果有函数有多个重名的参数，可以用arguments[i]读取，严格模式下，多个重名参数属于语法错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obi =&#123;</span><br><span class="line">    <span class="attr">username</span>:<span class="string">&#x27;smyh&#x27;</span>;</span><br><span class="line">    username:<span class="string">&#x27;vae&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，在严格模式下属于语法错误，因为有重名的属性。</p><h3 id="函数必须声明在顶层"><a href="#函数必须声明在顶层" class="headerlink" title="函数必须声明在顶层"></a>函数必须声明在顶层</h3><p>严格模式只允许在全局作用域或函数作用域的最顶层声明函数，也就是说，不允许在非函数的代码块内声明函数。</p><h3 id="新增关键字"><a href="#新增关键字" class="headerlink" title="新增关键字"></a>新增关键字</h3><p>严格模式新增保留字：</p><p>implements，interface，let，package，private，protected，public，static，yield。</p><h2 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h2><h3 id="json对象转化"><a href="#json对象转化" class="headerlink" title="json对象转化"></a>json对象转化</h3><ul><li><p>js对象（数组）–&gt; json对象（数组）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringfy(obj/arr)</span><br></pre></td></tr></table></figure></li><li><p>json对象（数组）–&gt; js对象（数组）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(json)</span><br></pre></td></tr></table></figure><p>上面两种方法是ES5中提供的。</p><p>我们常说的<strong>JSON字符串</strong>只有两种：json对象，json数组。</p><p><code>typeof json字符串</code>的返回值是String。</p></li></ul><h2 id="Object的扩展"><a href="#Object的扩展" class="headerlink" title="Object的扩展"></a>Object的扩展</h2><p>ES5给Object扩展了一些静态方法，常用的有2个。</p><ul><li>方法一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(prototype,[descriptors])</span><br></pre></td></tr></table></figure><p>作用：以指定对象为原型，创建新的对象，同时，第二个参数可以为新的对象添加新的属性，并对此属性进行描述。</p><p><strong>example1</strong>：（没有第二个参数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 =&#123;<span class="attr">username</span>:<span class="string">&#x27;smyhvae&#x27;</span>,<span class="attr">age</span>:<span class="number">26</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 =&#123;<span class="attr">address</span>:<span class="string">&#x27;shenzhen&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">obj2=<span class="built_in">Object</span>.create(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：obj1成为了obj2的原型</p><p><strong>example2</strong>:（有第二个参数时）</p><p>第二个参数可以给新的对象添加新的属性，我们修改上面的代码，尝试给obj2添加新属性<code>sex</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1=&#123;<span class="attr">username</span>:<span class="string">&#x27;smyhvae&#x27;</span>,<span class="attr">age</span>:<span class="number">26</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;<span class="attr">address</span>:<span class="string">&#x27;shenzhen&#x27;</span>&#125;;</span><br><span class="line">obj2=<span class="built_in">Object</span>.create(obj1,&#123;</span><br><span class="line">    <span class="attr">sex</span>:&#123;</span><br><span class="line">        <span class="attr">value</span>:<span class="string">&#x27;男&#x27;</span>，</span><br><span class="line">        writable：<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure><p>上方代码中，我们通过第5行的sex给obj2设置了一个新的属性<code>sex</code></p><p>但是要通过<code>value</code>来设置属性（第6行）。</p><p>设置完属性值后，这个属性值默认是不可修改的，要通过<code>writable</code>来设置。总而言之，这几个关键字解释入下：</p><ul><li><code>value</code>：设置属性值</li><li><code>writable</code>：标识当前属性值是否可修改 ，如果不写的话，默认为false，不可修改。</li><li><code>configurable</code>：标识当前属性是否可以被删除，默认为false，不可删除。</li><li><code>enumerable</code>：标识当前属性是否能用for in 枚举。默认为false，不可。</li></ul><h3 id="单独设置属性"><a href="#单独设置属性" class="headerlink" title="单独设置属性"></a>单独设置属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj2,<span class="string">&#x27;sex&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">value</span>:<span class="string">&#x27;cc&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>:<span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><blockquote><p>这个方法有点难理解</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(object,descriptors)</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：为指定对象定义扩展多个属性。</p><p><strong>example</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2=&#123;</span><br><span class="line">    <span class="attr">firstname</span>:<span class="string">&#x27;smyh&#x27;</span>,</span><br><span class="line">    <span class="attr">lastname</span>:<span class="string">&#x27;vae&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj2,&#123;</span><br><span class="line">    <span class="attr">fullName</span>:&#123;</span><br><span class="line">        <span class="attr">get</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.firstName+<span class="string">&#x27;-&#x27;</span>+<span class="built_in">this</span>.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> names = data.split(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">            <span class="built_in">this</span>.firstName=names[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">this</span>.lastName=names[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.fullName);</span><br><span class="line">obj2.firstName=<span class="string">&#x27;tim&#x27;</span>;</span><br><span class="line">obj2.lastName=<span class="string">&#x27;duncan&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.fullName);</span><br><span class="line">obj2.fullName=<span class="string">&#x27;kobe-bryant&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.fullName);</span><br></pre></td></tr></table></figure><ul><li>get： 用来获取当前属性值的回调函数</li><li>set：修改当前属性值得触发的回调函数，并且实参即为修改后的值</li></ul><h2 id="Object的扩展（二）"><a href="#Object的扩展（二）" class="headerlink" title="Object的扩展（二）"></a>Object的扩展（二）</h2><p>obj对象本身就自带了两个方法。格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get 属性名（）&#123;&#125;用来得到当前属性值的回调函数</span><br><span class="line">set 属性名（）&#123;&#125;用来监视当前属性值变化的回调函数</span><br></pre></td></tr></table></figure><p><strong>example</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">    <span class="attr">lastNmae</span>:<span class="string">&#x27;bryant&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">fullName</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName+<span class="string">&#x27;&#x27;</span>+<span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">data</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> names=data.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.firstName=names[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.lastName=names[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.fullName);</span><br><span class="line">obj.fullName=<span class="string">&#x27;curry stephen&#x27;</span>;</span><br><span class="line">cosnole.log(obj.fullName);</span><br></pre></td></tr></table></figure><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><blockquote><p>下面的方法都是给数组的实例用的</p></blockquote><p><strong>方法一</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.indexOf(value)</span><br></pre></td></tr></table></figure><p>作用：获取value在数组中的第一个下标。</p><p><strong>方法二</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.lastIndexOf(value)</span><br></pre></td></tr></table></figure><p>作用：获取value在数组中的最后一个下标。</p><p><strong>方法三</strong>：遍历数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p><strong>方法四</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>作用：遍历数组返回一个新的数组，返回的是<strong>加工之后</strong>的新数组。</p><p><strong>方法五</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>作用：遍历过滤出一个新的子数组，返回条件为true的值。</p><h2 id="函数function的扩展：bind（）"><a href="#函数function的扩展：bind（）" class="headerlink" title="函数function的扩展：bind（）"></a>函数function的扩展：bind（）</h2><blockquote><p>ES5中新增了bind（）函数来改变this的指向。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind(obj)</span><br></pre></td></tr></table></figure><p>作用：将函数内的this绑定为obj，并将函数返回。</p><p><strong>面试题</strong>：call()、apply()和bind()的区别：</p><ul><li>都能改变this的指向</li><li>call()\apply()是<strong>立即调用函数</strong></li><li>bind():绑定完this后，不会立即调用当前函数，而是<strong>将函数返回</strong>因此后面还需要再加（）才能调用。</li></ul><p>PS：bind()传参方式和call()一样。</p><p><strong>分析</strong>：</p><p>为什么ES5中要加入bind()方法来改变this的指向呢？因为bind()不会立即调用当前函数。</p><p>bind()通常使用在回调函数中，因为回调函数并不会立即调用。如果你希望在回调函数中改变this，不妨使用bind()。</p><h2 id="ES6的环境配置-（为了兼容ES5）"><a href="#ES6的环境配置-（为了兼容ES5）" class="headerlink" title="ES6的环境配置 （为了兼容ES5）"></a>ES6的环境配置 （为了兼容ES5）</h2><p>掌握ES6之后，如果要考虑ES5的兼容性，可以这样做：写ES6语法的JS代码，然后通过Babel将ES6转换为ES5。</p><p>但是，在这之前，我们需要配置一下相关的环境。</p><h3 id="建立工程目录"><a href="#建立工程目录" class="headerlink" title="建立工程目录"></a>建立工程目录</h3><ol><li>先建立一个空的工程目录ES6Demo，并在目录下建立两个文件夹src和dist：<ul><li>src：书写ES6代码，我们写的js程序都放在这里。</li><li>dist：利用Babel编译生成的ES5代码。<strong>我们在HTML页面需要引入dist里的js文件</strong>。</li></ul></li><li>在src里创建新建文件index.html：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scalej=1.0&quot;&gt;</span><br><span class="line">                &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;iek=edge&quot;&gt;</span><br><span class="line">                    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;script src=&quot;./dist/index.js&quot;&gt;&lt;/scrpt&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，上方代码中，我们引入的是dist目录下的js文件。</p><p>然后我们新建文件src/index .js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="string">&#x27;smyhvae&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="string">&#x27;qianguyihao&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure><p>这个文件是一个ES6语法的js文件，稍后，我们尝试把这个ES6语法的js文件转化为ES5的js文件 。</p><p>PS:我们在 写代码的时候，能用单引号尽量用单引号，而不是双引号，前者在压缩之后，程序会执行更快。</p><h2 id="全局安装Babel-Cli"><a href="#全局安装Babel-Cli" class="headerlink" title="全局安装Babel-Cli"></a>全局安装Babel-Cli</h2><p>（1） 初始化项目：</p><p>在安装Babel之前，需要先用npm init先初始化我们的项目。打开终端或者通过cmd打开命令行工具，进入项目目录，输入如下指令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>上方代码中，-y代表全部默认同意，就不用一次次按回车了（稍后在再根据需要，在文件中手动修改）。命令执行完成后，会在项目的根目录下生成package.json文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;es6demo&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>:<span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>:<span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;test&quot;</span>:<span class="string">&quot;echo  \&quot;Error:no test specified\&quot;&amp;&amp; exit1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;author&quot;</span>:<span class="string">&quot;smyhvae&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;license&quot;</span>:<span class="string">&quot;ISC&quot;</span>                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS: VS Code 里打开终端的快捷键是：Contol+~。</p><p>（2）全局安装Babel-cli：</p><p>在终端输入以下命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g babel-cli</span><br></pre></td></tr></table></figure><p>如果安装比较慢的话，MAC可以用cnpm安装，windows下可以使用npm切换到taobao镜像。</p><p>（3）本地安装babel-preset-es2015和babel-cli:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-preset-es2015 babel-cli</span><br></pre></td></tr></table></figure><p>安装完成后，会发现package.json文件，已经多了devDependencies选项：</p><p>（4）新建.babelrc:</p><p>在根目录下新建文件.babelrc，输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;presets&quot;:[</span><br><span class="line">&quot;es2015&quot;</span><br><span class="line">],</span><br><span class="line">&quot;plugins&quot;:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5)开始转换：</p><p>现在，我们应该可以将ES6的文件转化为ES5的文件了，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel src/ index.js -o dist/index.js</span><br></pre></td></tr></table></figure><p>我们可以将上面这个名令进行简化一下。操作如下：</p><p>在文件package.json中修改scripts中的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span>:<span class="string">&quot;babel src/index.js -o dist/index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前为止，环境配置好了。以后，我们执行如下命令，即可将src/index.js这个ES6文件转化为dist/index.js这个ES5文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p> 我们执行上面的命令后发现，dist目录下会生成ES5的JS文件：index.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a=<span class="string">&#x27;smyhvae&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b=<span class="string">&#x27;qianguyihao&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure><p>当我们打开网页后，就可以在浏览器的控制台，看到代码输出的结果。</p><h2 id="ES6的变量声明"><a href="#ES6的变量声明" class="headerlink" title="ES6的变量声明"></a>ES6的变量声明</h2><p>ES6中新增了let和const来定义变量：</p><ul><li>var：ES5和ES6中，定义<strong>全局变量</strong>（是variable的简写）。</li><li>let：定义**局部变量 **，替代var。</li><li>const：定义<strong>常量</strong>（定义后，不可更改）。</li></ul><h3 id="var-全局变量"><a href="#var-全局变量" class="headerlink" title="var:全局变量"></a>var:全局变量</h3><p>看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>上方代码是可以输出结果的，输出结果为1。因为var是全局声明的，所以 ，即使实在区块里声明，但仍然在全局起作用。</p><p>再看下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//这里的a指的是区块里的a</span></span><br></pre></td></tr></table></figure><p>上方代码的输出结果为2；因为var是全局声明的。</p><p><strong>总结：</strong></p><p> 用var定义的全局变量会污染整个js的作用域。</p><h3 id="let：定义局部变量"><a href="#let：定义局部变量" class="headerlink" title="let：定义局部变量"></a>let：定义局部变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>上方的代码输出结果为2。用let声明的变量，只在局部（<strong>块级作用域内</strong>）起作用。</p><p>let是防止数据污染，我们来看下面这个<strong>for循环</strong>的例子，很经典。</p><p>1、用var声明变量：（）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;循环体中：&#x27;</span>+i);</span><br><span class="line">    <span class="comment">//每循环一次，就会在&#123;&#125;所在的块级作用域中定义一个新的i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;循环体外：&quot;</span>+i);</span><br></pre></td></tr></table></figure><p>上方代码可以正常打印结果，且最后一行的打印结果是10。说明循环体外定义的变量i，是在全局起作用的。</p><p>2、用let声明变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;循环体外：&#x27;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;循环体外：&#x27;</span>+i);</span><br></pre></td></tr></table></figure><p>上方代码的最后一行无法打印结果，也就是说会打印报错。因为用let定义的变量i，只在{ }这个<strong>块级作用域</strong>里生效。</p><p><strong>总结：</strong>我们要习惯用let声明，减少var声明带来的污染全局空间。</p><p>为了进一步说明let不会带来污染，需要说明的是：当我们定义了let a=1时，如果我们在同一个作用域内继续定义let a = 2，是会报错的。</p><h3 id="const-定义常量"><a href="#const-定义常量" class="headerlink" title="const:定义常量"></a>const:定义常量</h3><p>在程序开发中，有些变量是希望声明后，在业务层就不再发生变化，此时可以用const来定义。</p><p><strong>example</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name=<span class="string">&#x27;smyhvae&#x27;</span>;</span><br></pre></td></tr></table></figure><p>用const声明的变量，只在局部（块级作用域内）起作用。</p><h3 id="let和const的作用【important】"><a href="#let和const的作用【important】" class="headerlink" title="let和const的作用【important】"></a>let和const的作用【important】</h3><p>let和const的作用如下：</p><ul><li>禁止重复声明 </li><li>支持块级作用域</li><li>控制修改</li></ul><p>相反，用var声明的变量：可以重复声明、<strong>没有块级作用域</strong>、不能限制。</p><h3 id="for循环举例【经典案例】"><a href="#for循环举例【经典案例】" class="headerlink" title="for循环举例【经典案例】"></a>for循环举例【经典案例】</h3><p><strong>代码1</strong>、我们先来看看如下代码：（用var定义变量i）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;aa&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bb&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cc&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dd&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> myBtn=<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;myBtn.length;i++)&#123;</span></span><br><span class="line"><span class="javascript">                myBtn[i].onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(i);</span></span><br><span class="line"><span class="javascript">                &#125;;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可能会感到诧异，为何点击任何一个按钮，弹出的内容都是4呢？这是因为，我们用var定义的变量i，实在全局作用域声明的。整个代码中，自始至终，只有一个变量。当我们还没点击按钮之前，变量i已经循环到4了。</p><p>也就是说，上面的for循环，相当于如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">myBtn[<span class="number">0</span>].onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">&#125;;</span><br><span class="line">i++;</span><br><span class="line">myBtn[<span class="number">1</span>].onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">&#125;;</span><br><span class="line">i++;</span><br><span class="line">myBtn[<span class="number">2</span>].onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">&#125;;</span><br><span class="line">i++;</span><br><span class="line">myBtn[<span class="number">3</span>].onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">&#125;;</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">//到这里，i的值已经是4了。因此，当我们点击按钮时，i的值一直都是4</span></span><br></pre></td></tr></table></figure><p><strong>代码2</strong>、上面的代码中，如果我们改为用let定义变量i：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;aa&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bb&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cc&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dd&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> myBtn=<span class="built_in">document</span>.getElementByTagName(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;myBtn.length; i++ )&#123;</span></span><br><span class="line"><span class="javascript">                myBtn[i].onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(i);</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们用let定义变量i，在循环的过程中，每执行一次循环体，就会诞生一个新的i。循环体执行4次，就会有4个i。</p><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>ES6允许我们，通过数组或者对象的方式，对一组变量进行赋值，这被称为解构。</p><p>解构赋值在实际开发中可以大量减少我们的代码量，并且让程序结构更清晰。</p><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><p><strong>举例</strong>：</p><p>通常情况下，我们为一组变量赋值时，一般是这样写的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> c=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>现在我们可以通过数组解构的方式进行赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>二者效果是一样的。</p><p><strong>解构的默认值</strong></p><p>在解构赋值时，是允许使用默认值的。举例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一个变量时</span></span><br><span class="line">    <span class="keyword">let</span> [foo=<span class="literal">true</span>]=[];</span><br><span class="line">    <span class="built_in">console</span>.log(foo);<span class="comment">//输出结果：true</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//两个变量时</span></span><br><span class="line">    <span class="keyword">let</span> [a,b]=[<span class="string">&#x27;生命一号&#x27;</span>]</span><br><span class="line">    <span class="comment">//a赋值为：生命一号。b没有赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(a+<span class="string">&#x27;,&#x27;</span>+b);</span><br><span class="line">    <span class="comment">//输出结果为：生命一号，undefined</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//两个变量时</span></span><br><span class="line">    <span class="keyword">let</span>[a,b=<span class="string">&#x27;smyhvae&#x27;</span>]=[<span class="string">&#x27;生命一号&#x27;</span>]</span><br><span class="line">    <span class="comment">//a赋值为：生命一号，b采用默认值：smyhvae</span></span><br><span class="line">    <span class="built_in">console</span>.log(a+<span class="string">&#x27;,&#x27;</span>+b);</span><br><span class="line">    <span class="comment">//输出结果：生命一号，smyhvae</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>undefined和null的区别：</p><p>如果我们在赋值时，采用的是undefined或者null，那会有什么区别呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> [a,b=<span class="string">&#x27;smyhvae&#x27;</span>]=[<span class="string">&#x27;生命一号&#x27;</span>，<span class="literal">undefined</span>];</span><br><span class="line">    <span class="comment">//b虽然被赋值为undefined，但是b会采用默认值</span></span><br><span class="line">    <span class="built_in">console</span>.log(a+<span class="string">&#x27;,&#x27;</span>+b);</span><br><span class="line">    <span class="comment">//输出结果：生命一号，smyhvae</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> [a,b=<span class="string">&#x27;smyhvae&#x27;</span>]=[<span class="string">&#x27;生命一号&#x27;</span>,<span class="literal">null</span>];</span><br><span class="line">    <span class="comment">//b被赋值为null</span></span><br><span class="line">    <span class="built_in">console</span>.log(a+<span class="string">&#x27;,&#x27;</span>+b);</span><br><span class="line">    <span class="comment">//输出结果：生命一号，null</span></span><br></pre></td></tr></table></figure><p>上方代码分析：</p><ul><li>undefined：相当于什么都没有，此时b采用默认值</li><li>null：相当于有值，但值为null</li></ul><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>通常情况下，我们从接口拿到json数据后，一般这么赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=json.a;</span><br><span class="line"><span class="keyword">var</span> b=json.b;</span><br><span class="line"><span class="keyword">var</span> c=json.c;</span><br></pre></td></tr></table></figure><p>上面这样写比较麻烦。</p><p>现在，我们同样可以针对对象，进行解构赋值。</p><p><strong>举例如下</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;foo,bar&#125;=&#123;<span class="attr">bar</span>:<span class="string">&#x27;我是bar的值&#x27;</span>,<span class="attr">foo</span>:<span class="string">&#x27;我是foo的值&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo+<span class="string">&#x27;,&#x27;</span>+bar);</span><br><span class="line"><span class="comment">//输出结果：我是键foo的值，我是键bar的值</span></span><br></pre></td></tr></table></figure><p>上方代码可以看出，对象的解构和数组的解构，有一个最重要的区别：<strong>数组</strong>的元素是按次序排列的，变量的取值由他的<strong>位置</strong>决定；而<strong>对象的属性没有次序</strong>，是<strong>根据键来取值的</strong>。</p><p><strong>圆括号的使用：</strong></p><p>如果foo在解构前就定义了，此时再去解构就会出问题。</p><p>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo=<span class="string">&#x27;haha&#x27;</span>;</span><br><span class="line">&#123; foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br></pre></td></tr></table></figure><p>需要解决报错，只要在解构的语句外边，加一个圆括号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;haha&#x27;</span>;</span><br><span class="line">(&#123; foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(foo);<span class="comment">//输出结果: aaa</span></span><br></pre></td></tr></table></figure><h3 id="字符串解构"><a href="#字符串解构" class="headerlink" title="字符串解构"></a>字符串解构</h3><p>字符串也可以解构，这是因为，此时字符串被转换为了一个类似数组的对象。举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a,b,c,d] = <span class="string">&#x27;aaaa&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">//输出结果：string</span></span><br></pre></td></tr></table></figure><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p>ES6中如果要遍历一个数组，可以这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> arr1)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for…of的循环可以避免 我们开拓内存空间，增加代码运行的效率，建议多使用。</p><p><strong>注意</strong>：上面的数组中，for…of获取的是数组里的值；for…in获取的是index索引值。</p><h3 id="Map对象的遍历"><a href="#Map对象的遍历" class="headerlink" title="Map对象的遍历"></a>Map对象的遍历</h3><p>for…of 既可以遍历数组，也可以遍历Map对象。</p><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>我们以前让字符串进行拼接的时候。可以这样做：（传统写法的字符串拼接）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">&#x27;aaaa&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age=<span class="string">&#x27;26&#x27;</span>;</span><br><span class="line">]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span>+name+<span class="string">&#x27;,age:&#x27;</span>+age);<span class="comment">//传统写法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`name:<span class="subst">$&#123;name&#125;</span>,age:<span class="subst">$&#123;age&#125;</span>`</span>);<span class="comment">//ES6写法</span></span><br></pre></td></tr></table></figure><p>传统写法比较繁琐且容易出错，ES6写法更为实用</p><p><strong>注意</strong>，上方代码中，倒数第二行使用的符号是反引号（tab键上方）</p>]]></content>
    
    
    <summary type="html">ES5,ES6特性详解</summary>
    
    
    
    <category term="前端学习" scheme="https://laocuicode.cn/daydream/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前端" scheme="https://laocuicode.cn/daydream/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JS" scheme="https://laocuicode.cn/daydream/tags/JS/"/>
    
    <category term="Ecmascript" scheme="https://laocuicode.cn/daydream/tags/Ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>Python实现词频分析和词云生成</title>
    <link href="https://laocuicode.cn/daydream/2020/11/11/Python%E5%AE%9E%E7%8E%B0%E8%AF%8D%E9%A2%91%E5%88%86%E6%9E%90%E5%92%8C%E8%AF%8D%E4%BA%91%E7%94%9F%E6%88%90/"/>
    <id>https://laocuicode.cn/daydream/2020/11/11/Python%E5%AE%9E%E7%8E%B0%E8%AF%8D%E9%A2%91%E5%88%86%E6%9E%90%E5%92%8C%E8%AF%8D%E4%BA%91%E7%94%9F%E6%88%90/</id>
    <published>2020-11-10T16:00:00.000Z</published>
    <updated>2020-11-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于建模需要，博主简单学习了词频分析和词云生成，本博客仅适用于初学者第一次使用来借鉴</p><span id="more"></span><h1 id="Python实现词频分析和词云生成"><a href="#Python实现词频分析和词云生成" class="headerlink" title="Python实现词频分析和词云生成"></a>Python实现词频分析和词云生成</h1><p><em>1. 词频分析</em></p><p><strong>词频分析：</strong>所谓词频分析就是对一篇文章中的高频词语进行列举并计数</p><p><strong>实现方式：</strong>调用nltk的库，对.txt文本进行操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line"><span class="keyword">from</span> nltk.tokenize <span class="keyword">import</span> word_tokenize</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">stop_words = nltk.corpus.stopwords.words(<span class="string">&#x27;english&#x27;</span>)</span><br><span class="line"><span class="comment">#stop_words调用nltk预先定义好的不需要统计的词语字典</span></span><br><span class="line">newStopWords = [<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;It&#x27;</span>,<span class="string">&#x27;The&#x27;</span>,<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;use&#x27;</span>,<span class="string">&#x27;this&#x27;</span>,<span class="string">&#x27;They&#x27;</span>,<span class="string">&#x27;Im&#x27;</span>,<span class="string">&#x27;If&#x27;</span>,<span class="string">&#x27;So&#x27;</span>,<span class="string">&#x27;But&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;us&#x27;</span>,<span class="string">&#x27;My&#x27;</span>,\</span><br><span class="line">                <span class="string">&#x27;This&#x27;</span>,<span class="string">&#x27;We&#x27;</span>,<span class="string">&#x27;These&#x27;</span>,<span class="string">&#x27;You&#x27;</span>,<span class="string">&#x27;For&#x27;</span>,<span class="string">&#x27;She&#x27;</span>,<span class="string">&#x27;He&#x27;</span>,<span class="string">&#x27;Yet&#x27;</span>,<span class="string">&#x27;As&#x27;</span>]</span><br><span class="line"><span class="comment">#newStopWords定义不需要筛选的词语</span></span><br><span class="line">stop_words.extend(newStopWords)</span><br><span class="line"><span class="comment">#将不需要统计的词语添加到nltk的stopwords字典中</span></span><br><span class="line"><span class="built_in">list</span> = os.listdir(<span class="string">&#x27;C:/Users/25496/Desktop/建模/原文&#x27;</span>)</span><br><span class="line"><span class="comment">#list声明需要进行词频统计的文章的存储路径（本脚本会将该路径下所有的文档进行词频统计）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> content <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;C:/Users/25496/Desktop/建模/原文/&#x27;</span>+content, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 读取文件中的字符串</span></span><br><span class="line">        txt = f.read()</span><br><span class="line">        <span class="comment"># 去除字符串中的标点、数字等</span></span><br><span class="line">        txt = re.sub(<span class="string">&#x27;[,\.()&quot;:;!@#$%^&amp;*\d]|\&#x27;s|\&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, txt)</span><br><span class="line">        <span class="comment"># 替换换行符，大小写转换，拆分成单词列表</span></span><br><span class="line">        word_list = txt.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>).replace(<span class="string">&#x27;  &#x27;</span>, <span class="string">&#x27; &#x27;</span>).lower().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        word_tokens = word_tokenize(txt)</span><br><span class="line">        filtered_sentence = []</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word_tokens:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> stop_words:</span><br><span class="line">                filtered_sentence.append(w)</span><br><span class="line">        word_count_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> filtered_sentence:</span><br><span class="line">            <span class="comment"># 统计字典中的词频</span></span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> word_count_dict.keys():</span><br><span class="line">                word_count_dict[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                word_count_dict[word] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 按照单词出现次数排序</span></span><br><span class="line">        word_count_dict = <span class="built_in">sorted</span>(word_count_dict.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 输出到文件（如果是多个文件会输出到同一目录下）</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;C:/Users/25496/Desktop/建模/结果/result_&quot;</span>+content, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="keyword">as</span> f1:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> word_count_dict:</span><br><span class="line">                f1.write(<span class="string">&quot;%s\t%s\n&quot;</span> % (i[<span class="number">0</span>], <span class="built_in">str</span>(i[<span class="number">1</span>])))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>容易出现的问题：</strong></p><p>导nltk的数据包报错</p><p>在安装nltk的包之后我们还需要去安装nltk的数据包，至于缺少的数据包，这里作者建议各位在调试上述程序运行时的报错信息来确认缺少的数据包，下载时可以在python控制台输入如下指令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一种：图形用户界面,这种方式会生成一个图形用户界面，用户根据自己的需求来下载需要的数据包</span></span><br><span class="line">nltk.download()</span><br><span class="line"><span class="comment">#第二种：命令行下载</span></span><br><span class="line">nltk.download(<span class="string">&#x27;【包名】&#x27;</span>)</span><br></pre></td></tr></table></figure><p>常有报错：</p><p>（本机积极拒绝等。。。）这种问题出现的原因作者也出现了，多试几次之后莫名其妙就成功了。</p><p><em>2.词云生成</em></p><p><strong>词云：</strong>如各位所见就是由多个词汇组合而成的一种图片，适合在各种场合使用</p><p><strong>实现方式：</strong>调用wordcloud库（这个库好像需要matlab的库作为依赖）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">import</span> PIL.Image <span class="keyword">as</span> image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#list定义了需要做词频分析的文件的存储路径</span></span><br><span class="line"><span class="built_in">list</span> = os.listdir(<span class="string">&#x27;C:/Users/25496/Desktop/建模/原文&#x27;</span>)</span><br><span class="line"><span class="comment">#mask定义了一个图形蒙版</span></span><br><span class="line">mask = np.array(image.<span class="built_in">open</span>(<span class="string">&quot;C:/Users/25496/Desktop/建模/模板/timg.jpg&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> content <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;C:/Users/25496/Desktop/建模/原文/&#x27;</span> + content,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        text = fp.read()</span><br><span class="line">    <span class="comment"># print(text)</span></span><br><span class="line">        <span class="comment">#生成词云</span></span><br><span class="line">        wordcloud = WordCloud(background_color=<span class="string">&quot;white&quot;</span>,mask=mask).generate(text)</span><br><span class="line">        wordcloud.to_file(<span class="string">&quot;C:/Users/25496/Desktop/建模/词云/img_&quot;</span>+content+<span class="string">&quot;.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>WordCloud（）方法内置的一些属性：</strong></p><p>该方法可用来定义词云的基本属性</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">width</td><td align="center"><strong>指定词云对象生成图片的宽度，默认400像素</strong></td></tr><tr><td align="center">height</td><td align="center"><strong>指定词云对象生成图片的高度，默认200像素</strong></td></tr><tr><td align="center">min_font_size</td><td align="center"><strong>指定词云中字体的最小字号，默认4号</strong></td></tr><tr><td align="center">max_font_size</td><td align="center"><strong>指定词云中字体的最大字号，根据高度自动调节</strong></td></tr><tr><td align="center">font_step</td><td align="center"><strong>指定词云中字体字号的步进间隔，默认为1</strong></td></tr><tr><td align="center">font_path</td><td align="center"><strong>指定字体文件的路径，默认None</strong></td></tr><tr><td align="center">max_words</td><td align="center"><strong>指定词云显示的最大单词数量，默认200</strong></td></tr><tr><td align="center">stop_words</td><td align="center"><strong>指定词云的排除词列表，即不显示的单词列表</strong></td></tr><tr><td align="center">mask</td><td align="center"><strong>指定词云形状，默认为长方形，需要指定mask</strong></td></tr><tr><td align="center">background_color</td><td align="center"><strong>指定词云图片的背景颜色，默认为黑色</strong></td></tr></tbody></table><p><strong>mask要求：</strong>作为蒙版，需要是白底的图片，词云将会以图片深色部分作为轮廓生成</p>]]></content>
    
    
    <summary type="html">简单的数据分析和词云生成</summary>
    
    
    
    <category term="Python学习" scheme="https://laocuicode.cn/daydream/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://laocuicode.cn/daydream/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="nltk" scheme="https://laocuicode.cn/daydream/tags/nltk/"/>
    
    <category term="wordcloud" scheme="https://laocuicode.cn/daydream/tags/wordcloud/"/>
    
    <category term="Python数据分析" scheme="https://laocuicode.cn/daydream/tags/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="建模" scheme="https://laocuicode.cn/daydream/tags/%E5%BB%BA%E6%A8%A1/"/>
    
    <category term="词频分析" scheme="https://laocuicode.cn/daydream/tags/%E8%AF%8D%E9%A2%91%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>零散学习日记1</title>
    <link href="https://laocuicode.cn/daydream/2020/09/05/Day01%202020.9.6%20%20%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01/"/>
    <id>https://laocuicode.cn/daydream/2020/09/05/Day01%202020.9.6%20%20%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01/</id>
    <published>2020-09-04T16:00:00.000Z</published>
    <updated>2020-10-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>博主比较懒也比较菜，学习日记这种东西更新绝对不会太频繁！</p><span id="more"></span><h1 id="Day01-2020-9-6-学习日记1"><a href="#Day01-2020-9-6-学习日记1" class="headerlink" title="Day01 2020.9.6  学习日记1"></a>Day01 2020.9.6  学习日记1</h1><ol><li><p>role属性</p><ul><li>role属性的作用是告诉Accesibility类应用（如屏幕阅读器等）当前元素的作用，可以增强文本的可读性和语义化</li><li>在Html5元素内，标签本身就是有语义的，因此role可以作为可选属性使用，但类似于Bootstrap中都很重视类似的属性和声明，目的是为了兼容老版浏览器</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--role属性的使用--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--标明页面容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span> <span class="attr">role</span>=<span class="string">&quot;banner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nav</span> <span class="attr">role</span>=<span class="string">&quot;navigation&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--标明该处是导航--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span> <span class="attr">role</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--标明页面主体--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span>&gt;</span>text<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span>&gt;</span>example<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span> <span class="attr">role</span> =<span class="string">&quot;complementary&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span> <span class="attr">role</span> =<span class="string">&quot;complementary&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">role</span>=<span class="string">&quot;contentinfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义图标的方法</p><ul><li>图标：在网页导航栏中显示的网页标签中文字前方的图标</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--首先准备一张16*16px的图标（网页专用）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在HTML5文档中输入如下代码即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>流的定义</p><ul><li>流表示图表，照片，图形，插图，代码片段等独立的内容，在HTML5之前没有专门实现这个目的的元素，一些开发人员使用没有语义的div元素来表示</li><li>HTML5使用figure和figcaption引入流，其中figcaption表示流的标题，流的标题不是必须的，但如果包含它，就必须是figure内嵌的第一个或者最后一个元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>XXXXXXXX<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>picture标签及响应式效果的实现</p><ul><li><p>picture标签属性：</p><ol><li>srcset：必需，设置图片文件路径，如“srcset=”img/minpic.png””，或者是用逗号分隔的用像素密度描述的图片路径，如“srcset=”img/minpic.png,img/maxpic.png 2x””</li><li><em>media</em> ：设置媒体查询，如media=”(min-width:320px)”</li><li>sizes:设置宽度，如sizes=”100vw”，或是媒体查询宽度，如sizes=”(min-width:320px) 100vw”,可用逗号分隔形成媒体查询宽度列表</li><li>type：设置MIME类型，如type=”image/webp”或者type=”image/vnd.ms-photo”</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width:650px)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;images/kitten-large.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width:456px)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;images/kitten-medium.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--img标签用于不支持picture元素的浏览器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/kitten-small.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;a cute kitten&quot;</span> <span class="attr">id</span>=<span class="string">&quot;picimg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <summary type="html">简单记录了学习的一些前端零散知识</summary>
    
    
    
    <category term="前端学习" scheme="https://laocuicode.cn/daydream/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://laocuicode.cn/daydream/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="前端" scheme="https://laocuicode.cn/daydream/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="零散" scheme="https://laocuicode.cn/daydream/tags/%E9%9B%B6%E6%95%A3/"/>
    
  </entry>
  
  <entry>
    <title>MySql指令(不定时更新)</title>
    <link href="https://laocuicode.cn/daydream/2020/09/05/Mysql%E6%8C%87%E4%BB%A4%EF%BC%88%E8%BE%B9%E5%AD%A6%E8%BE%B9%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://laocuicode.cn/daydream/2020/09/05/Mysql%E6%8C%87%E4%BB%A4%EF%BC%88%E8%BE%B9%E5%AD%A6%E8%BE%B9%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2020-09-04T16:00:00.000Z</published>
    <updated>2020-10-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>更新全凭心情，学习时间随机</p><span id="more"></span><h1 id="Mysql指令（边学边更新）"><a href="#Mysql指令（边学边更新）" class="headerlink" title="Mysql指令（边学边更新）"></a>Mysql指令（边学边更新）</h1><ol><li><p>安装服务： mysqld –install</p></li><li><p>初始化：mysqld –initialize –console</p></li><li><p>开启服务：net start mysql</p></li><li><p>关闭服务：net stop mysql</p></li><li><p>登录mysql：mysql -u root -p</p><p>​    Enter PassWord：（密码）</p></li><li><p> 修改密码：alter user ‘root‘@’localhost’ identified by ‘root’</p></li><li><p> 标记删除mysql服务：sc delete mysql</p></li></ol>]]></content>
    
    
    <summary type="html">对后端数据库指令的整合</summary>
    
    
    
    <category term="Web后端学习" scheme="https://laocuicode.cn/daydream/categories/Web%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://laocuicode.cn/daydream/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="后端" scheme="https://laocuicode.cn/daydream/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="MySql" scheme="https://laocuicode.cn/daydream/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>python+opencv自学笔记（1）</title>
    <link href="https://laocuicode.cn/daydream/2020/06/05/python+opencv%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://laocuicode.cn/daydream/2020/06/05/python+opencv%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
    <published>2020-06-04T16:00:00.000Z</published>
    <updated>2020-06-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-opencv自学笔记（1）"><a href="#python-opencv自学笔记（1）" class="headerlink" title="python+opencv自学笔记（1）"></a>python+opencv自学笔记（1）</h1><h2 id="读取图像"><a href="#读取图像" class="headerlink" title="读取图像"></a><em>读取图像</em></h2><p>示例：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">src=cv.imread(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;input_image&#x27;</span>, cv.WINDOW_AUTOSIZE)</span><br><span class="line">cv.imshow(<span class="string">&#x27;input_image&#x27;</span>, src)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><ul><li><h3 id="cv-imread-方法"><a href="#cv-imread-方法" class="headerlink" title="cv.imread()方法"></a><code>cv.imread()</code>方法</h3></li></ul><p><em>参数：</em></p><p><code>cv.imread(&#39;path&#39;)</code></p><p><em>作用：</em></p><p>读取path路径下的图片（<strong>注意：path要为绝对路径且保证全英文</strong>）</p><ul><li><h3 id="cv-namedWidow-方法"><a href="#cv-namedWidow-方法" class="headerlink" title=" cv.namedWidow()方法"></a><code> cv.namedWidow()</code>方法</h3></li></ul><p><em>参数：</em></p><p><code>cv.namedWindow(&#39;image&#39;,cv.Window_AUUTOSIZE)</code></p><p><em>作用：</em></p><p>用于创建一个窗口，第一个参数为窗口的名称，第二个参数则是窗口的属性（可以省略，默认值为cv.WINDOW_AUTOSIZE）</p><ul><li><h3 id="cv-imshow-方法"><a href="#cv-imshow-方法" class="headerlink" title="cv.imshow()方法"></a><code>cv.imshow()</code>方法</h3></li></ul><p><em>参数：</em></p><p><code>cv.imshow(&#39;image&#39;,src)</code></p><p><em>作用：</em></p><p>在指定的窗口显示一副图像，第一个参数是窗口名称，第二个参数是图片对象</p><p>（<strong>注意：该方法可与上文中cv.namedWindow()联合使用，指定窗口的属性，然后在窗口中显示图片</strong>）</p><ul><li><h3 id="cv-waitKey-方法"><a href="#cv-waitKey-方法" class="headerlink" title=" cv.waitKey()方法"></a><code> cv.waitKey()</code>方法</h3></li></ul><p><em>参数：</em></p><p><code>cv.waitKey(0)</code></p><p>参数=0：（<em>可以是小于0的数值</em>）一直显示，无返回值  ，如果在键盘上按某个键会消失，则返回值为该按键对应的ascii码</p><p>参数&gt;=0： 该参数表示显示多少毫秒   超过该时间则返回-1</p><ul><li><h3 id="cv-destroyAllWindows"><a href="#cv-destroyAllWindows" class="headerlink" title="cv.destroyAllWindows()"></a><code>cv.destroyAllWindows()</code></h3></li></ul><p><em>参数：</em></p><p>无参数</p><p><em>作用：</em></p><p>删除建立的全部窗口（<strong>注意：该删除并非是指关闭显示出来的窗口，而是删除创建窗口所占用的内存</strong>），释放资源</p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python-opencv自学笔记（1）&quot;&gt;&lt;a href=&quot;#python-opencv自学笔记（1）&quot; class=&quot;headerlink&quot; title=&quot;python+opencv自学笔记（1）&quot;&gt;&lt;/a&gt;python+opencv自学笔记（1）&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="机器视觉" scheme="https://laocuicode.cn/daydream/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="opencv" scheme="https://laocuicode.cn/daydream/tags/opencv/"/>
    
  </entry>
  
</feed>
